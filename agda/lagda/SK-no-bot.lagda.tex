%% This file was automatically generated by agda2lagda 0.2021.6.1.

%% 
%% {-# OPTIONS --postfix-projections #-}
%% 
%% -- Strong normalization for simply-typed combinatory algebra
%% -- using Girard's reducibility candidates.
%% 
%% module SK-no-bot where

\subheading{Preliminaries}

We work in type theory with propositions-as types.

\begin{code}
Proposition = Set
\end{code}

Negation: A proposition is false if it implies any other proposition.

\begin{code}
¬̇_ : Proposition → Set₁
¬̇ A = ∀{C : Proposition} → A → C
\end{code}

\subheading{Syntax}

Types:
For simplicity, we consider a single base type.
Types are closed under function space formation.

\begin{code}
infixr 6 _⇒_

data Ty : Set where
  o    : Ty
  _⇒_  : (a b : Ty) → Ty
\end{code}

We use small latin letters from the beginning of the alphabet to range over types.

\begin{code}
variable a b c : Ty
\end{code}

Intrinsically well-typed terms of combinatory algebra (CA):
these are applicative terms over the constants K and S.

\begin{code}
infixl 5 _∙_

data Tm : Ty → Set where
  K    : Tm (a ⇒ (b ⇒ a))
  S    : Tm ((c ⇒ (a ⇒ b)) ⇒ (c ⇒ a) ⇒ c ⇒ b)
  _∙_  : (t : Tm (a ⇒ b)) (u : Tm a) → Tm b
\end{code}

We use small latin letters t, u and v to range over terms.

\begin{code}
variable t t′ u u′ v v′ : Tm a
\end{code}

The reduction relation is given inductively
via axioms for fully applied K and S
and congruence rules for the reduction
in either the function or the argument part
of an application.

\begin{code}
infix 4 _↦_

data _↦_ : (t t′ : Tm a) → Set where
  ↦K  : K ∙ t ∙ u      ↦ t
  ↦S  : S ∙ t ∙ u ∙ v  ↦ t ∙ v ∙ (u ∙ v)
  ↦l  : t ↦ t′  → t ∙ u ↦ t′ ∙ u
  f↦  : u ↦ u′  → t ∙ u ↦ t ∙ u′
\end{code}

\subheading{Strong normalization}

Sets of terms of a fixed type are expressed as predicates on
terms of that type.

\begin{code}
Pred : Ty → Set₁
Pred a = (t : Tm a) → Proposition

variable P Q : Pred a
\end{code}

The subset relation is implication of predicates.

\begin{code}
infix 2 _⊂_

_⊂_ : (P Q : Pred a) → Proposition
P ⊂ Q = ∀{t} → P t → Q t
\end{code}

Strong normalization: a term is SN if all of its reducts are, inductively.

\begin{code}
data SN (t : Tm a) : Proposition where
  acc : t ↦_ ⊂ SN → SN t
\end{code}

Reducts of SN terms are SN by definition.

\begin{code}
sn-red : SN t → t ↦ t′ → SN t′
sn-red (acc sn) r = sn r
\end{code}

In combinatory algebra, the values are the underapplied functions.
All values formed from SN components are SN.
The proofs proceed by induction on the SN of the arguments,
considering all possible one-step reducts of the values.

K is SN.

\begin{code}
sn-K : SN (K {a} {b})
sn-K = acc λ()
\end{code}

K applied to one SN argument is SN.

\begin{code}
sn-Kt : SN t → SN (K {a} {b} ∙ t)
sn-Kt (acc snt) = acc λ{ (f↦ r) → sn-Kt (snt r) }
\end{code}

S is SN.

\begin{code}
sn-S : SN (S {c} {a} {b})
sn-S = acc λ()
\end{code}

S applied to one SN argument is SN.

\begin{code}
sn-St : SN t → SN (S ∙ t)
sn-St (acc snt) = acc λ{ (f↦ r) → sn-St (snt r) }
\end{code}

S applied to two SN arguments is SN.

\begin{code}
sn-Stu : SN t → SN u → SN (S ∙ t ∙ u)
sn-Stu (acc snt) (acc snu) = acc λ where
  (↦l (f↦ r))  → sn-Stu (snt r) (acc snu)
  (f↦ r)       → sn-Stu (acc snt) (snu r)
\end{code}

\subheading{Reducibility candidates}

Following Girard, terms which are not introductions are called neutral.
In CA, the weak head redexes are the neutrals.

\begin{code}
data Ne : Pred a where
  Ktu   : Ne (K ∙ t ∙ u)
  Stuv  : Ne (S ∙ t ∙ u ∙ v)
  napp  : (n : Ne t) → Ne (t ∙ u)
\end{code}

Partially applied combinators, i.e., values, are thus not neutral.

\begin{code}
Kt¬ne : ¬̇ Ne (K {a} {b} ∙ t)
Kt¬ne (napp ())

Stu¬ne : ¬̇ Ne (S ∙ t ∙ u)
Stu¬ne (napp (napp ()))
\end{code}

A reducibility candidate (CR) for a type is a set of SN terms of that type
(condition CR1).
Further, the set needs to be closed under reduction (CR2).
Finally, a candidate needs to contain any neutral term of the right type
whose reducts are already in the candidate (CR3).

\begin{code}
record CR (P : Pred a) : Proposition where
  field
    cr1  : P ⊂ SN
    cr2  : P t → (t ↦_) ⊂ P
    cr3  : (n : Ne t) (h : t ↦_ ⊂ P) → P t
open CR
\end{code}

The set SN is a reducibility candidate.

\begin{code}
sn-cr : CR (SN {a})
sn-cr .cr1 sn   = sn
sn-cr .cr2 sn   = sn-red sn
sn-cr .cr3 _ h  = acc h
\end{code}

Given two reducibility candidates, one acting as the domain
and one as the codomain, we form a new reducibility candidate,
the function space.

The function space contains any SN term that, applied to a term
in the domain, yields a result in the codomain.

\begin{code}
record _⇨_ (P : Pred a) (Q : Pred b) (t : Tm (a ⇒ b)) : Proposition where
  field
    sn   : SN t
    app  : ∀ {u} (⦅u⦆ : P u) → Q (t ∙ u)
open _⇨_
\end{code}

The function space construction indeed operates on CRs.

CR1 holds by definition.
The proof of CR2 only needs CR2 of the codomain.
The proof of CR3 needs CR3 of the codomain and CR1 and CR2 of the domain.

\begin{code}
⇨-cr : (crP : CR P) (crQ : CR Q) → CR (P ⇨ Q)
⇨-cr                  crP crQ .cr1 ⦅t⦆                  = ⦅t⦆ .sn
⇨-cr                  crP crQ .cr2 ⦅t⦆ r .sn            = sn-red (⦅t⦆ .sn) r
⇨-cr                  crP crQ .cr2 ⦅t⦆ r .app ⦅u⦆       = crQ .cr2 (⦅t⦆ .app ⦅u⦆) (↦l r)
⇨-cr                  crP crQ .cr3      n ⦅t⦆ .sn       = acc λ r → ⦅t⦆ r .sn
⇨-cr {P = P} {Q = Q}  crP crQ .cr3 {t}  n ⦅t⦆ .app ⦅u⦆  = loop ⦅u⦆ (crP .cr1 ⦅u⦆)
\end{code}

  We perform a side induction on the SN of the function argument,
  exploiting that the domain is closed under reduction.

\begin{code}
  where
  loop : ∀{u} → P u → SN u → Q (t ∙ u)
  loop ⦅u⦆ (acc snu) = crQ .cr3 (napp n) λ where
    ↦K      → Kt¬ne n
    ↦S      → Stu¬ne n
    (↦l r)  → ⦅t⦆ r .app ⦅u⦆
    (f↦ r)  → loop (crP .cr2 ⦅u⦆ r) (snu r)
\end{code}

\subheading{Soundness}

Interpretation of types as semantic types:
we interpret the base type as the set of all SN terms of that type
and the function type via the function space construction.

\begin{code}
⟦_⟧ : ∀ a → Pred a
⟦ o ⟧      = SN
⟦ a ⇒ b ⟧  = ⟦ a ⟧ ⇨ ⟦ b ⟧
\end{code}

Types are indeed interpreted as CRs.

\begin{code}
ty-cr : ∀ a → CR ⟦ a ⟧
ty-cr o        = sn-cr
ty-cr (a ⇒ b)  = ⇨-cr (ty-cr a) (ty-cr b)
\end{code}

Any term in a semantic type is SN.

\begin{code}
sem-sn : ⟦ a ⟧ t → SN t
sem-sn ⦅t⦆ = ty-cr _ .cr1 ⦅t⦆
\end{code}

Interpretation of S:
constant S, fully applied to terms inhabiting the respective semantic types,
inhabits the correct semantic type as well.

This lemma is proven by induction on the SN of the subterms,
redundant facts which we add explicitly for the sake of recursion.
The induction hypothesis is applicable thanks to CR2.

\begin{code}
⦅S⦆  :  ⟦ c ⇒ a ⇒ b ⟧ t  → SN t
     →  ⟦ c ⇒ a ⟧ u      → SN u
     →  ⟦ c ⟧ v          → SN v
     →  ⟦ b ⟧ (S ∙ t ∙ u ∙ v)

⦅S⦆ {b = b} ⦅t⦆ (acc snt) ⦅u⦆ (acc snu) ⦅v⦆ (acc snv) = ty-cr b .cr3 Stuv λ where
  ↦S                 → ⦅t⦆ .app ⦅v⦆ .app (⦅u⦆ .app ⦅v⦆)
  (↦l (↦l (f↦ rt)))  → ⦅S⦆  (ty-cr _ .cr2 ⦅t⦆ rt) (snt rt)
                            ⦅u⦆ (acc snu)
                            ⦅v⦆ (acc snv)
  (↦l (f↦ ru))       → ⦅S⦆  ⦅t⦆ (acc snt)
                            (ty-cr _ .cr2 ⦅u⦆ ru) (snu ru)
                            ⦅v⦆ (acc snv)
  (f↦ rv)            → ⦅S⦆  ⦅t⦆ (acc snt)
                            ⦅u⦆ (acc snu)
                            (ty-cr _ .cr2 ⦅v⦆ rv) (snv rv)
\end{code}

Interpretation of K: analogously.

\begin{code}
⦅K⦆ : ⟦ a ⟧ t → SN t → SN u → ⟦ a ⟧ (K ∙ t ∙ u)
⦅K⦆ {a} ⦅t⦆ (acc snt) (acc snu) = ty-cr a .cr3 Ktu λ where
  ↦K            → ⦅t⦆
  (↦l (f↦ rt))  → ⦅K⦆ (ty-cr a .cr2 ⦅t⦆ rt) (snt rt) (acc snu)
  (f↦ ru)       → ⦅K⦆ ⦅t⦆ (acc snt) (snu ru)
\end{code}

Term interpretation: each term inhabits its respective semantic type.

Proof by induction on the term.

\begin{code}
⦅_⦆ : (t : Tm a) → ⟦ a ⟧ t
⦅ S {b = b} ⦆ .sn                         = sn-S
⦅ S {b = b} ⦆ .app ⦅t⦆ .sn                = sn-St  (⦅t⦆ .sn)
⦅ S {b = b} ⦆ .app ⦅t⦆ .app ⦅u⦆ .sn       = sn-Stu (⦅t⦆ .sn) (⦅u⦆ .sn)
⦅ S {b = b} ⦆ .app ⦅t⦆ .app ⦅u⦆ .app ⦅v⦆  = ⦅S⦆ {b = b}  ⦅t⦆ (sem-sn ⦅t⦆)
                                                         ⦅u⦆ (sem-sn ⦅u⦆)
                                                         ⦅v⦆ (sem-sn ⦅v⦆)
⦅ K ⦆ .sn                                 = sn-K
⦅ K ⦆ .app ⦅t⦆ .sn                        = sn-Kt (sem-sn ⦅t⦆)
⦅ K ⦆ .app ⦅t⦆ .app ⦅u⦆                   = ⦅K⦆ ⦅t⦆ (sem-sn ⦅t⦆) (sem-sn ⦅u⦆)
⦅ t ∙ u ⦆                                 = ⦅ t ⦆ .app ⦅ u ⦆
\end{code}

Strong normalization is now a simple corollary.

\begin{code}
thm : (t : Tm a) → SN t
thm t = sem-sn ⦅ t ⦆
\end{code}

